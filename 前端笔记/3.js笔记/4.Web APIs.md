##  1.web APIs和js基础关联性

### 1.1js组成

![image-20230510175528435](../../../../Typora/js笔记图片/image-20230510175528435.png)

### 1.2js基础阶段以及web APIs阶段

**JS 基础阶段**

- 我们学习的是ECMAScript 标准规定的基本语法
- 要求同学们掌握Js基础语法
- 只学习基本语法，做不了常用的网页交互效果
- 目的是为了Js后面的课程打基础、做铺垫

**Web APIs 阶段**

- web APIS是W3C组织的标准
- web APIs我们主要学习 DOM 和BOM
- web APIS是我们JS 所独有的部分我们主要学习页面交互功能
- 需要使用Js础的课程内容做基础

## 2.API 和Web API

### 2.1API

==API(Application Programminglnterface,应用程序编程接口)==是一些预先定义的函数，目的是提供应用程序与开发人员基于某软件或硬件得以访问一组例程的能力，而又无需访问源码，或理解内部工作机制的细节。

### 2.2 Web API

==Web API==是浏览器提供的一套操作==浏览器功能==和==页面元素==的API（BOM和DOM）。

# 2.DOM

## 1.DOM简介

### 1.1什么是DOM

文档对象模型（Document Object Model，简称DOM），是W3C组织推荐的处理可扩展标记语言（HTML或者XML）的标准编程接口

可以通过这些接口来改变网页的内容和样式

### 1.2DOM树

- 文档：一个页面就是一个文档，DOM中使用document表示
- 元素：页面中的所有标签都是元素，DOM中使用elelment表示
- 节点：网页中的所有内容都是节点（标签，属性，文本，注释等），DOM中使用node表示

**==DOM把以上内容都看做是对象==**

## 2.获取元素

### 2.1如何获取页面元素

DOM在实际开发中主要用来操作元素

**获取方式**

- 根据ID获取
- 根据标签名获取
- 通过HTML5新增的方法获取
- 特殊元素获取

### 2.2根据id获取

使用getElementByld（）方法可以获取带有id的元素对象

1. 因为我们文档页面从上往下加载，所以先得有标签 所以我们script写到标签的下面
2. get 获得 element 元素 by 通过 驼峰命名法
3. 参数 id是大小写敏感的字符串
4. 返回的是一个元素对象
5. console.dir打印我们的元素对象 更好的查看里面的属性方法

### 2.3根据标签名获取

使用getElementsByTagName0方法可以返回带有指定标签名的==对象的集合==

返回的是 获取过来元素对象的集合 以伪数组的形式储存的

**==注意==**：

1. 因为得到的是一个对象的集合，所以我们想要操作里面的元素就需要遍历
2. 得到元素对象是动态的
3. 如果页面中只有一个li 返回的还是伪数组的形式
4. 如果页面中没有li 返回的是空的伪数组的形式

还可获取某个元素（父元素）内部所有指定标签名的子元素

```js
element.getElementByTagName('标签名')；
```

注意：父元素必须是==单个对象（必须指明是哪一个元素对象）==。获取的时候不包括父元素自己

### 2.4通过HTTML5新增的方法获取

```js
1.document.getElementByClassName('类名')；//根据类名返回元素对象集合
2.document.querySelecor（'选择器'）;//根据指定选择器返回第一个元素对象切记选择器需要加符号 类加点id加# 
3.document.querySelecorAll（'选择器'）；//根据指定选择器返回
```



### 2.5获取特殊元素（body，html）

- 获取body元素

  ```js
  document.body//返回body元素对象
  ```

  

- 获取html元素 

  ```js
  document.documentElement;//返回html元素对象
  ```

  

## 3.事件基础

### 3.1事件概述

事件被理解为JavaScript检测到的行为

简答理解：触发---响应机制。

网页中每个元素都可以产生可以触发JavaScript的事件 例子：点击按钮执行某些操作

### 3.2事件三要素

事件是有三部分组成的：

- 事件源
- 事件类型
- 时间处理程序

1. 事件源 事件被触发的对象 
2. 事件类型 如何触发 什么事件比如鼠标点击鼠标经过键盘按下等等
3. 事件处理程序 通过一个函数赋值的方式完成

### 3.3执行事件的步骤

1. 获取事件源
2. 注册事件（绑定程序）
3. 添加事件处理程序（采取函数赋值形式）

### 补充知识（常见的鼠标事件）

| 鼠标事件    | 触发条件         |
| ----------- | ---------------- |
| onclick     | 鼠标点击左键触发 |
| onmouseover | 鼠标经过触发     |
| onmouseout  | 鼠标离开触发     |
| onfocus     | 获得鼠标焦点触发 |
| onblur      | 失去鼠标焦点触发 |
| onmousemove | 鼠标移动触发     |
| onmouseup   | 鼠标弹起触发     |
| onmousedown | 鼠标按下触发     |

## 4.操作元素

JavaScript的 DOM操作可以改变网页内容、结构和样式，我们可以利用DOM操作元素来改变元素里面的内容、属性等。注意以下都是属性

### 4.1改变元素内容

```js
element.innerText
```

**从起始位置到终止位置的内容，但它去除html标签，同时空格和换行也会去掉**

```js
element.innerHTML
```

**起始位置到终止位置的全部内容，包括html标签，同时保留空格和换行**

innerText和innerHTML的区别

1. innerText不识别html标签 非标准 ==去除空格和换行==
2. innerHTML识别HTML标签 W3C标准==保留空格和换行==
3. 这两个属性都是可读写的，可以获取元素的内容

### 4.2常用元素的属性操作

```

1.innerText.innerHTML改变元素内容
2.src.herf
3.id、alt、title
```

### 4.3表单元素的属性操作

利用dom可以操作如下表单元素：

```js
type、value、checked、selected、disabled
```

### 4.4样式元素操作

我们可以通过js改变元素的大小颜色位置等样式

```js
1.elelment.style 行内样式操作
2.element.className 类名样式操作
```

==**注意：**==

1.  js里面的样式采用驼峰命名法比如fonsize.backgroundColor
2.  js修改style样式操作，产生的是行内样式，css权重比较高
3. 如果样式修改较多，可以通过采取类名方式更改元素样式
4. class因为是个保留字。因此使用className来操作元素类名属性
5. className 会直接改变元素类名，会覆盖原先的类名

### 4.5排他思想

如果有同一组元素，我们想要某一个元素实现某种样式，需要用到循环的排他思想算法:

1. 所有元素全部清除样式(干掉其他人)

2. 给当前元素设置样式(留下我自己)
3. 注意顺序不能乱，首先干掉其他人，再设置自己

### 4.6自定义属性操作

#### 1.获取属性值

- ==element.属性== 获取属性值

- element.getAttribute('属性')

- ==element.属性== 获取内置属性值（元素本身自带的属性）

- element.getAttribute('属性')，主要获得自定义的属性（标准）我们程序员自定义的属性值

#### 2.设置属性值

- element.属性=’值‘ 设置内置属性值
- element.setAttribute('属性’，‘值’）；主要针对于自定义属性

#### 3.移除属性值

- element.removeAttribute（‘属性’）

### 4.7H5自定义属性

==**自定义属性目的:是为了保存并使用数据。有些数据可以保存到页面中而不用保存到数据库中**==

自定义属性获取是通过getAttribute(属性)获取

但是有些自定义属性很容易引起歧义，不容易判断是元素的内置属性还是自定义属性

H5给我们新增了自定义属性

#### 1.设置H5自定义属性

H5规定自定义属性date-开头作为属性名并且赋值

==比如<div date-index='1'><div>==

#### 2.获取H5自定义属性

1. 兼容性获取 element.getAttribute('data-index');
2. H5新增element.dataset。index或者element。dataset['index']   ie11才开始支持

## 5.节点操作

### 5.1为什么要学习节点操作

获取元素通常使用两种方式：

1. 利用dom提供的一些方法获取元素
   - document.getElementById（）
   - 逻辑性不强，繁琐

2. 利用节点层级获取元素
   - 利用父子兄节点获取元素
   - 逻辑性强但是兼容性稍差

这两种方法都可以获取元素节点，我们后面都会使用但是节点操作更简单

### 5.2节点概述

网页中的所有内容都是节点(标签、属性、文本、注释等)，在DOM中，节点使用node 来表示HTMLDOM树中的所有节点均可通过JavaScript进行访问，所有HTML元素(节点)均可被修改，也可以创建或删除。

一般地，节点至少有nodeType（节点类型），nodeName（节点名称）和nodeValue（节点值）这三个基本属性

- 元素节点 nodeType为1
- 属性节点 nodeType为2
- 文本节点 nodeType 为3（文本节点包含文字空格换行等）

==实际开发中。节点操作的是元素节点==

### 5.3节点层级

利用DOM树可以把节点分为不同的层级关系，常见的是==父子兄层级关系==

#### 1.父级节点

```js
node.parentNode
```

#### 2.子节点

```js
1.parentNode.childNodes(标准)
```

parentNode.childNodes返回包含指定的节点的子节点的集合，该集合为即时更新的集合

==**注意**：返回值里面包含了所有的子节点，包含元素节点，文本节点等。如果只想要获取里面的元素节点。则需要专门处理，所以我们一般不提倡使用childNodes==

```js
var ul=document.querySelector('ul');
for(var i=0;i<ul.childNodes.length;i++){
if(ul.childNode[i].nodeType==i}{
//ul.childNodes[i]是元素节点
console.log(ul.childNodes[i])；
}
}
```

```js
2.parentNode.children(非标准)
```

paerntNode.children是一个只读属性，返回所有的子元素节点 它返回子元素节点，其余节点不返回

虽然children是一个非标准，但是得到了各个浏览器的支持，因此我们可以放心使用

```js
3.parentNode.firstChild
```

firstChild返回第一个子节点，找不到则返回null同样也是包含==所有的节点==

```js
4.parentNode.lastchild
```

lastChild返回最后一个子节点，找不到则返回null同样也是包含==所有的节点==

```js
5.parentNode.firstElementChild
```

返回第一个==元素节点==

```js
6.parentNode.lastElementChild
```

==**注意**：这两个方法有兼容问题，IE9以上才支持==

解决兼容性和便捷的问题：		

Element.children[0]：获取第一个

Element.children[element.length-1]；获取最后一个

#### 3.兄弟节点

```js
1.node.nextSibling
```

nextSibing返回当前元素的下一个兄弟节点，找不到返回null，同样，也是包含==所有的节点==				

```js
2.node.previousSibing
```

previousSibing返回当前元素的上一个兄弟节点，找不到返回null，同样，也是包含==所有的节点==

```js
3.node.nextElementibling
```

nextElement返回下一个兄弟==元素节点==，找不到则返回null

```js
3.node.lastElementibling
```

lastElement返回下一个兄弟==元素节点==，找不到则返回null

==**注意**：这两个方法有兼容问题，IE9以上才支持==

如何解决这个问题：

```js
function getNextElementsibling(element){
var el = element ;
while (el = el.nextsibling) {if(el .nodeType=== 1)
return el;
}
}
return null;
}
```

### 5.4创建节点

```js
document.creatElement('tagName')
```

document.creatElement()方法创建由tagName指定的HTML元素，因为这些元素原先不存在是根据我们得需求动态生成的，所以我们称为==动态创建元素节点==	

### 5.5添加节点

```js
node.appendChild(child)
```

node.appendChild()方法将一个节点添加到指定的父节点的子节点列表==尾部==，类似于css里面的after伪元素

```js
node.insertBefore(child,指定元素)
```

node.insertBefore（）方法是将一个节点添加到父节点的指定子节点==前面==，类似于css里面的before伪元素 

### 5.6删除节点

```js
node.removeChild（child）
```

node.removeChild()方法从DOM中删除一个子节点，返回删除的节点

### 5.7复制节点（克隆节点）

```js
node.cloneNode（）
```

node.cloneNode（）方法返回调用该方法的节点的一个副本，也称为克隆节点/拷贝节点

**注意**：

1. 如果函数括号参数为==空或者为false==，则是浅拷贝，即只是克隆节点本身，不克隆里面的子节点

2. 如果函数括号参数为==true==，则是深拷贝，即只是复制节点里面的内容  

### 5.8三种动态创建元素区别

- document.write（）
- element.innerHTML
- document.createElement（）

**区别**：

1. document.write是直接将内容写入页面的内容流，==但是文档执行完毕，则他会导致页面全部重绘==
2.  innerHTML是将内容写入某个DOM节点，不会导致页面重新绘制
3. innerHTML创建多个元素效率更高（不要拼接字符串，采取数组形式拼接），结构稍微复杂
4. creatElement（）创建多个元素效率稍微低一点但是结构更清晰

==**总结**：不同浏览器下，innerHTML效率要比creatElement高==

## 6.DOM重点核心

1. 对于JavaScript，为了能够使JavaScript操作HTMLJavaScript就有了一套自己的dom编程接口
2. 对HTML，dom使得html形成一课dom树包含文档，元素，节点

关于dom操作，我们主要针对于元素的操作主要有创建，增，删，改，查，属性操作，事件操作

### 6.1创建

1. document.write
2. innerHTML
3. creatElement

### 6.2增

1. appendChild
2. insertBefore

### 6.3删

1. removeChild

### 6.4改

主要修改dom的元素属性，dom元素的内容、属性,表单的值等

1. 修改元素属性:src、href、title等
2. 修改普通元素内容:innerHTML、innerText
3. 修改表单元素:value、type、disabled等
4. 修改元素样式:style、className

### 6.5查

主要获取查询dom的元素

1. DOM提供的API方法: getElementByld、getElementsByTagName 古老用法不太推荐
2. H5提供的新方法: querySelector、querySelectorAll 提倡
3. 利用节点操作获取元素: 父parentNode)、子(children)、兄(previousElementSibling .ne xtElementSibling)提倡

### 6.6属性操作

主要针对于自定义属性

1. setAttribute：设置dom的属性值
2. getAttribute：得到dom的属性值
3. removeAttribute移除属性

### 6.7事件操作

该元素注册事件，采取事件源.事件类型=事件处理程序

| 鼠标事件    | 触发条件         |
| ----------- | ---------------- |
| onclick     | 鼠标点击左键触发 |
| onmouseover | 鼠标经过触发     |
| onmouseout  | 鼠标离开触发     |
| onfocus     | 获得鼠标焦点触发 |
| onblur      | 失去鼠标焦点触发 |
| onmousemove | 鼠标移动触发     |
| onmouseup   | 鼠标弹起触发     |
| onmousedown | 鼠标按下触发     |

# 3.事件高级

## 1.注册事件(绑定事件)

### 1.1注册事件概述

给元素添加事件，称为==注册事件==或者==绑定事件==

注册事件有两种方式：==传统方式和方法监听注册方式==

##### 传统方式

- 利用on开头的事件onclick
- <button onclick="alert('hi~')"></button>
- btn.onclick=function（）{}
- 特点：注册事件的==唯一性==
- 同一个元素同一个事件只能设置一个处理函数，最后注册的处理函数将会覆盖前面的处理函数

##### 方法监听注册方式

- w3c标准推荐
- addEventListener（）它是一个方法
- IE9之前的IE不支持此方法，可使用attachEvent（）代替
- 特点：同一个元素同一个事件可以注册多个监听器
- 按注册顺序依次执行

### 1.2addEventListener 事件监听方式

```js
eventTarget.addEventListener（type，listener[,useCapture]）
```



eventTarget,addEvenListener()方法将指定的监听器注册到eventTarget（目标对象）上，当该对象触发指定的事件时，就会执行事件处理函数

该方法接收三个参数：

- type :事件类型==字符串==必定加引号，比如 click、mouseover，注意这里不要带on
- listener: 事件处理函数，事件发生时，会调用该监听函数
- useCapture:可选参数，是一个布尔值，默认是false。学完DOM事件流后，我们再进一步学习

### 1.3attachEvent 事件监听方式（非标准尽量不要在生产环境中使用）ie9之前的版本支持

```js
eventTarget.attachEvent（eventNameWithOn，callback）
```

eventTarget.attachEvent（）方法将指定的监听器注册到eventTarget（目标对象）上，当该对象触发指定事件时，指定的回调函数就会被执行

该方法接收两个参数：

- eventNameWithOn：事件类型字符串，比如onclick，onmousover，这里要带on
- callback：事件处理函数，当目标触发事件时回调函数被调用

### 1.4注册事件兼容性解决方案

```js
function addEventListener（element，eventName,fn）{
//判断当前浏览器是否支持 addEventListener 方法
if（element.addEventListener）{
element.addEventListener(eventName，fn); 
// 第三个参数 默认是false
else if (element.attachEvent) {
element.attachEvent('on' + eventName, fn);
}else (
// 相当于 element.onclick = fn;
element['on' + eventName] = fn;
}

}
```

==兼容性处理的原则：首先照顾大多数浏览器，再处理特殊浏览器==

## 2.删除事件（解绑事件）

### 2.1删除事件的方式

**1.传统注册方式**

eventTarget.onclick=null；

**2.方法监听机制**

1. eventTarget.removeEventListener（type，lister[，useCapture]）；
2. eventTarget.detachEvent (eventNameWithOn,callback);

### 2.2删除事件兼容性解决方案



```js
function removeEventListener(element, eventName, fn) {
//判断当前浏览器是否支持 removeEventistener 方法
if (element .removeEventListener) {
element.removeEventListener(eventName，fn); 
// 第三个参数 默认是false
}else if (element .detachEvent) (
element.detachEvent ('on' + eventName , fn);
}else (
element['on' + eventName] = null;
}
```

## 3.DOM事件流

==事件流==描述的是从页面中接收事件的顺序

==事件==发生时会在元素节点之间按照特定的顺序传播，这个==传播过程==即==DOM事件流==

DOM事件流分为3个阶段：

1. 捕获阶段
2. 当前目标阶段
3. 冒泡阶段

- 事件冒泡：IE中最早提出，事件开始时由最具体的元素接收，然后逐级向上传播到DOM最顶层节点的过程 
- 事件捕获：网景最早提出，由DOM最顶层节点开始，然后逐级向下传播到最具体的元素接收的过程

**注意：**

1. js代码中最多只能执行捕获或者冒泡其中一个阶段
2. onclick和attachEvent只能得到冒泡阶段
3. addEventListener(type，listener[，useCapture])第三个参数如果是 true，表示在事件捕获阶段调用事件处理程序;如果是 false(不写默认就是false)，表示在事件冒泡阶段调用事件处理程序。
4. 实际开发中我们更关注==冒泡==（从小到大）
5. 有些事件是没有冒泡的，比如onblur，onfous，onmouseenter，onmouseleave

## 4.事件对象

### 4.1什么是事件对象

```js
eventTarget.onclick = function (event){}
eventTarget.addEventListener('click', function(event) {})
// 这个 event 就是事件对象，我们还喜欢的写成 e 或者 evt
```

官方解释:event对象代表事件的状态，比如键盘按键的状态、鼠标的位置、鼠标按钮的状态.简单理解:事件发生后，跟事件相关的一系列信息数据的集合都放到这个对象里面，这个对象就是事件对象event，它有很多属性和方法
比如 :

1. 谁绑定了这个事件
2. 鼠标触发事件的话，会得到鼠标的相关信息，如鼠标位置

### 4.2事件对象的使用语法

```js
eventTarget,onclick=functioon(event){
//这个event就是事件对象，我们还喜欢写成e或者evt
}
eventTarget.addEventListener（'click',function(event){
//这个event就是事件对象，我们还喜欢写成e或者evt
})
```

系统自动创建的想当于形参不用传实参

### 4.3事件对象的兼容性方案

事件对象本身的获取存在兼容问题

1. 标准浏览器中是浏览器给方法传递的参数，只需要定义形参e就可以获取到。
2. 2在IE6~8中，浏览器不会给方法传递参数，如果需要的话，需要window.event 中获取查找。

==解决:
e = e ll window.event;==

### 4.4事件对象的常见属性和方法

| 事件对象属性方法    | 说明                                                         |
| ------------------- | ------------------------------------------------------------ |
| e.target            | 返回==触发==事件   标准（和this的区别this是事件整体e.target是点谁返回谁） |
| e.srcElement        | 返回==触发==事件的对象  非标准ie6-8使用                      |
| e.type              | 返回事件的类型 比如click mouseover                           |
| e.cancleBubble      | 该属性阻止冒泡 非标准 ie6-8使用                              |
| e.returnValue       | 该属性阻止默认事件（默认行为） 非标准 ie6-8使用 比如不让链接跳转 |
| e.preventDefault()  | 该方法阻止默认事件（默认行为）标准 比如不让链接跳转（传统的注册方式也可以用return但是return发生后后面的代码拒不执行了） |
| e.stopPropagation() | 阻止冒泡 标准                                                |

## 5.阻止事件冒泡

### 5.1阻止事件冒泡的两种方式

事件冒泡：就是开始时从小到大传播到DOM顶层节点

**阻止事件冒泡：**

- 标准写法：利用事件对象里面的stopPropagation（）方法

### 5.2阻止事件冒泡的兼容性解决方案

```js
if（e&&e.stopPropagation）{
e.stopPropagation（）；

}else{
window.event.cancleBubble=true；
}
```

## 6.事件委托（代理、委托)

事件冒泡本身特性，会带来坏处，也会带来好处需要灵活运用

==事件委托==也叫事件代理在JQ里面称呼为事件委派

==**事件委托的原理**==

==*不要给每个子节点设置事件监听器，而是将事件监听器设置在其父节点上，然后利用冒泡原理影响到设置的每个子节点*==

事件委托的作用：

只操作一次DOM提高了程序的性能

## 7.常用的鼠标事件

### 7.1常用的鼠标事件

##### 1.禁用鼠标右键菜单

contextmenu主要控制何时显示上下文菜单，主要用于程序员取消默认的上下文菜单

```js
document.addEventListener('contextmenu',function(e){
e.preventDefault();
})
```

##### 2.禁止鼠标选中（selectstart 开始选中）

```js
document.addEventListener('selectstart',function(e){
e.preventDefault();
})
```

### 7.2鼠标事件对象

==event==对象代表事件的状态，跟事件相关的一系列信息的集合，现阶段主要用鼠标事件对象

==MouseEvent==和鼠标时间对象==keyboardEvent==

| 鼠标事件对象 | 说明                                        |
| ------------ | ------------------------------------------- |
| e.clientX    | 返回鼠标相对于浏览器窗口==可视区==的 X 坐标 |
| e.clientY    | 返回鼠标相对于浏览器窗口==可视区==的Y坐标   |
| e.pageX      | 返回鼠标相对于文档页面的X坐标 IE9+ 支持     |
| e.pageY      | 返回鼠标相对于文档页面的Y 坐标 IE9+支持     |
| e.screenX    | 返回鼠标相对于电脑屏幕的 X 坐标             |
| e.screenY    | 返回鼠标相对于电脑屏幕的Y 坐标              |

## 8.常见的鼠标事件

### 8.1常用的键盘事件

事件除了使用鼠标触发，还可以用键盘触发

| 键盘事件   | 触发条件                                                     |
| ---------- | ------------------------------------------------------------ |
| onkeyup    | 某个键盘按键被松开时触发                                     |
| onkeydown  | 某个键盘按键被按下时触发                                     |
| onkeypress | 某个键盘按键被按下时触发 ==但是他不识别功能键 比如Ctrl shift箭头等== |

- 先执行down再执行press最后是up
- addEventListener不加on传统的加

### 8.2键盘事件对象

| 键盘事件对象==属性== | 说明              |
| -------------------- | ----------------- |
| keyCode              | 返回该键的ASCLL值 |

up和down不区按键大小写都是大写字母的ascll码

press可以区分大小写

**注意：**keydown和keypress在文本框里的特点：他们两个触发的时候文字还没落入文本框

### 8.3ASCLL表

![在ascll码表中,根据码值由小到大的排列顺序是？_文档下载](../../../../Typora/js笔记图片/1-577-png_6_0_0_54_496_784_555_892.5_1263-816-0-0-816.jpg)

# 4.BOM 浏览器对象模型

## 1.BOM概述



### 1.1什么是BOM

BOM（Browser Object Model）即==浏览器对象模型==，他提供了独立于内容而与==浏览器窗口进行交互的对象==其核心对象是Window

BOM由一系列相关对象构成，并且每个对象都提供了很多方法和属性

BOM缺乏标准，JavaScript语法的标准化组织是ECMA ，DOM的标准化组织是W3C，BOM最初是Netscape浏览器标准的一部分

**DOM**

- 文档对象模型
- DOM就是把[文档]当做一个[对象]来看待

- DOM的顶级对象是document
- DOM主要学习的是操作页面元素
- DOM是W3C标准规范

**BOM**

- 浏览器对象模型
- 把[浏览器]当做一个[对象]来看待
- BOM的顶级对象是window
- BOM学习的是浏览器窗口交互的一些对象
- BOM是浏览器厂商在各自浏览器上定义的，兼容性较差

### 1.2BOM的构成

BOM比DOM更大，它包含DOM

![image-20230518191402819](../../../../Typora/js笔记图片/image-20230518191402819-1684408451756-3.png)

==**window对象是浏览器的顶级对象**==，他有双重角色

1. 它是js访问浏览器窗口的一个接口
2. 它是一个全局对象，定义在全局作用域中的变量，函数都会变成window对象的属性和方法

在调用的时候可省略window，前面学习的对话框都属于window对象方法，如alert（），prompt（）等

==**注意：**window下的一个特殊属性window.name==

## 2.window对象的常见事件

### 2.1窗口加载事件

```js
window.onload=function(){}
或者
window.addEventLisener("load",function(){});
```

window.onload是窗口（页面）加载事件，当文档内容完全加载完成会触发该事件（包括图像，脚本文件，css文件等）就调用的函数

**注意：**

1. 有了window.onload就可以把js代码写到页面元素的上方，因为onload是等页面内容加载完毕才会去执行处理函数
2. window.onload传统注册事件只能写一次，如果有一个就以最后一个为准
3. 如果使用addEventListener则没有限制

```js
doocument.addEventListener('DOMContentLoaded'，funcion(){})
```

DOMContentLoaded事件触发时，仅当DOM加载完成，不包括样式表，图片，flash等等

ie9以上才支持

如果页面中的图片很多从用户访问到onload触发可能需要很长时间，影响用户体验，这个时候用DOMContentLoaded事件合适

### 2.2调节窗口大小事件

```js
window.onresize=function(){}
或者
window.addEventListener('resize',function(){})
```

==**注意：**==

1.  只要窗口大小发生变化，就会触发这个事件
2. 我们经常利用这个事件完成响应式布局，window.innerWidth就是当前屏幕的宽度

## 3.定时器

### 3.1两种定时器

window对象给我们提供了2个定时器

- setTimeout（）
- setInterval（） 

### 3.2setTime（）定时器

```js
window.setTimeout(调用函数，[延迟的毫秒数])
```

setTimeout（)方法用于设置一个定时器，该定时器在定时器到期后执行调用函数

setTimeout（)这个调用函数也叫回调函数callback，简单理解就是回头在调用你

**注意：**

1. window可以省略
2. 这个调用函数可以==直接写函数，或者写函数名==或者采取字符串 ’函数名（）’三种形式第三种不推荐
3. 延迟的毫秒数省略默认是0，如果写必须是毫秒
4. 因为定时器可能有很多，所以我们经常给定时器赋值一个标识符

### 3.3停止setTimeout（）定时器

```js
window.clearTimeout(timeout ID)
```

**注意：**

1. window可以省略
2. 里面的参数就是定时器的标识符

### 3.4setInterval（）定时器

```js
wiindow.setInterval(回调函数，[间隔的毫秒数])
```

setInterval方法==重复==调用一个函数，每搁这个时间就去调用一次

**注意：**

1. window可以省略
2. 这个调用函数可以==直接写函数，或者写函数名==或者采取字符串 ’函数名（）’三种形式第三种不推荐
3. 延迟的毫秒数省略默认是0，如果写必须是毫秒
4. 因为定时器可能有很多，所以我们经常给定时器赋值一个标识符

### 3.5停止seInterval（）定时器

```js
window.clearInterval（intervalID）;
```

clearInterval()方法取消了先前通过调用setInter val()  建立的定时器
**注意:**

1. window可以省略
2. 里面的参数就是定时器的标识符

### 3.6this

this的指向在函数定义的时候是指定不了的。只有函数执行的时候才能确定this到底指向谁。一般情况下this的最终指向是那个调用它的对象

## 4.js执行机制

### 4.1js是单线程

JavaScript语言的一大特点就是单线程也就是说同一个时间只能做一件事，这是因为JavaScript这门脚本语言诞生的使命所致---JavaScript是为处理页面中用户的交互。以及操作DOM而诞生的比如我们对某个DOM元素进行添加和删除操作，不能同时进行，应该先进行添加之后再删除

==单线程：==就意味着所有任务都需要排队，前一个任务结束，才会执行后一个任务，这样就导致如果js执行的时间过长就会导致页面的渲染不连贯，导致页面渲染加载阻塞的感觉

### 4.3同步和异步

为了解决加载阻塞的问题，利用多核CPU的计算能力，HTML5提出了Web Worker标准，允许JavaScript脚本创建多个线程于是js中出现了==同步==和==异步==

同步：按顺序一个一个来

异步：做一个事的同时还处理其他的

**同步任务**：会在一个主线程形成一个执行线

**异步任务：**

js的异步任务是通过回调函数实现的

一般而言，异步任务有以下是三种类型。

1. 普通事件，如click，resize等
2. 资源加载，如load，error等
3. 定时器，包括setintereval，setTimeout等

异步任务相关==回调函数==添加到==任务队列==中（任务队列也称为消息队列）

### 4.4js执行机制

1. 先执行执行栈中的同步任务
2. 异步任务（回调函数）放入任务队列中
3. 一旦执行栈中的所有同步任务执行完毕，系统就会依次读取==任务队列==中的异步任务，于是被读取的异步任务结束等待状态，进入执行栈，开始执行

由于主线程不断重复获得任务，执行任务，再获取任务，再执行，所以这种机制称为==事件循环==

## 5.location对象

### 5.1什么是location对象

window对象给我们提供了一个==localtion属性==用于==获取或设置窗体的URL==，并且可以用于==解析URL==，因为这个属性返回的是一个对象，所以这个属性也称为==location对象==

### 5.2URL

统一资源定位符(Uniform Resource Locator, URL)是互联网上标准资源的地址，与联网上的每个文件都有一个唯一的URL，它包含的信息指出文件的位置以及浏览器应该怎么处理它

URL的一般语法格式为：

```
protocol://host:portl/path/[?query]#fragment
http://www.itcast.cn/index.html?name=andy&age=18#link
```

![image-20230519092511262](../../../../Typora/js笔记图片/image-20230519092511262-1684459517466-5.png)

### 5.3location对象的属性

| location对象属性    | 返回值                              |
| ------------------- | ----------------------------------- |
| ==lacation.herf==   | 获取或者设置整个URL                 |
| lacation.host       | 返回主机（域名）www.itheima.com     |
| lacation.port       | 返回端口号 如果未写返回空字符串     |
| lacation.pathname   | 返回路径                            |
| ==lacation.search== | 返回参数（字符串类型）              |
| lacation.hash       | 返回片段 #后面内容 常见用于链接锚点 |

### 5.4location对象的方法

| location对象方法   | 返回值                                                      |
| ------------------ | ----------------------------------------------------------- |
| location.assign()  | 跟href一样，可以跳转页面（也称为重定向页面）                |
| location.replace() | 替换当前页面，因为不记录历史，所以不后退页面                |
| location.reload()  | 重新加载页面，相当于刷新按钮或者f5如果参数为true强制ctrl+f5 |

## 6.navigator对象

navigator对象包含有关浏览器的信息，他有很多属性，我们最常用的是userAgent，该属性可以返回由客户机发送服务器的user-agent头部的值

下面前端代码可以判断用户那个终端打开页面，实现跳转

```js
if((navigator.userAgent.match(/(phone|pad|pod|iphone|ipod|ios|ipad||Android|Mobile|BlackBerry|IEMobile|MQQBrowser||JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i))){
window.location.href="";//手机
}else{
window.location.href="";//电脑
}
```

## 7.history对象

wiindow对象给我们提供了一个history==对象==，与浏览器历史记录进行交互，该对象包含用户（在浏览器窗口中）访问过的URL

| history 对象方法 | 作用                                                    |
| ---------------- | ------------------------------------------------------- |
| back（）         | 可以后退功能                                            |
| forward（）      | 前进功能                                                |
| go（参数）       | 前进后退功能 参数如果是1前进1个页面如果是-1后退一个页面 |

# 5.pc端网页特效

## 1.元素偏移量offset系列

### 1.1offset概述

offset翻译过来就是偏移量，我们使用offset系列相关属性可以==动态的==得到该元素的位置（偏移），大小等

- 获得元素距离带有定位父元素的位置
- 获取元素自身的大小（宽度高度）
- 注意：返回的数值都不带单位

offset系列常用属性：

| offset系列属性       | 作用                                                         |
| -------------------- | ------------------------------------------------------------ |
| element.offsetParent | 返回作为该元素带有定位的父级元素，如果父级元素都没有定位则返回body |
| element.offsetTop    | 返回元素相对带有定位父元素上方的偏移                         |
| element.offsetLeft   | 返回元素相对带有定位父元素左边框的偏移                       |
| element.offsetWidth  | 返回自身包括padding，边框，内容区的宽度，返回值不带单位      |
| element.offsetHeight | 返回自身包括padding边框，内容区的高度，返回数值不带单位      |

### 1.2offset与style区别

**offset**

- offset可以得到任意样式表中的样式值
- offset系列获得的数值是没有单位的
- offsetWidth包含padding +border +widthoff setWidth等 属性是只读属性，只能获取不能赋值
- 所以，我们想要获取元素大小位置，用offset更合适

**style**

- style只能很到行内样式表中的样式值
- style.width获得的是带有单位的字符串
- style.width获得不包含padding和border的值
- style.width是可读写属性，可以获取也可以赋值
- 所以，我们想要给元素更改值，则需要用style改变

## 2.元素可视区client系列

==client== 翻译过来就是客户端，我们使用client 系列的相关属性来获取元素可视区的相关信息。通过client系列的相关属性可以动态的得到该元素的边框大小、元素大小等。

| client系列属性       | 作用                                                         |
| -------------------- | ------------------------------------------------------------ |
| element.clientTop    | 返回元素上边框的大小                                         |
| element.clientLeft   | 返回元素左边框的大小                                         |
| element.clientWidth  | 返回自身包括padding，内容区的宽度，不含边框，返回数值不带单位 |
| element.clientHeight | 返回自身包括padding，内容区的高度，不含边框，返回值不带单位  |

**立即执行函数：**

语法：(function(){})()或者(function(){}())

用处：创建一个独立的作用域，避免命名冲突

## 3.元素滚动scroll系列

### 3.1元素scroll系列属性

==scrol==翻译过来就是滚动的，我们使用scroll系列的相关属性可以动态的得到该元素的大小，滚动距离等等

| scroll系列属性       | 作用                                               |
| -------------------- | -------------------------------------------------- |
| element.scrollTop    | 返回被卷去的上测距离，返回数值不带单位             |
| element.scrollLeft   | 返回被卷去的左侧距离，返回数值不带单位             |
| element.scrollWidth  | 返回自身==实际的宽度==，不含边框，返回数值不带单位 |
| element.scrollHeight | 返回自身==实际高度==，不含边框，返回数值不带单位   |

**真实的内容高度和宽度**

### 3.2页面被卷去的头部

如果浏览器的高（或宽）度不足以显示整个页面时会自动出现滚动条，当滚动条向下滚动时，压面上面被隐藏的高度就是被卷去的头部，滚动条在滚动时会触发onscroll事件



### 3.3 页面被卷去的头部兼容性解决方案

需要注意的是，页面被卷取得头部，有兼容性问题，因此被卷去的头部通常有如下几种写法：

1. 声明了DTD，使用document.documentElement.scrollTop
2. 未声明DTD，使用document.body.scrollTop
3. 新方法window.pageYOffset和window.pageXOffset，IE9开始支持

```js
function getScroll(){
return {
left:window.pageXOffset||document.documentElement.scrollLeft||document.body.scrollLeft||0,
top:window.pageYOffset||document.documentElemen.scrollTop||document.body.scrollTop||0
}
}
使用的时候 getscroll().left
```

## 三大元素总结

他们的主要用法：

1. offset系列经常用于获得元素位置 ==offsetLeft offsetTop==
2. scroll经常用于获取元素大小==clientWidth clientHeight==
3. scroll经常用语言获取滚动距离==scrollTop scrollLeft==
4. ==注意页面的滚动距离通过==window.pageXOffset获得

## mouseenter和mouseover的区别

**mouseenter鼠标事件**

- 当鼠标移动到元素上时就会触发mouseenter事件
- 类似于mouseover，它们两者之间的差别是
- mouseover鼠标经过自身盒子会触发，经过子盒子还会触发，mouseenter只会经过自身盒子触发
- 之所以这样是因为mouseenter不会冒泡
- 跟mouseenter搭配鼠标离开mouseleave同样不会冒泡 

## 4.动画函数封装

### 4.1动画实现原理

==核心原理：==通过定时器setInterval（）不断移动盒子位置

实现步骤：

1. 获得盒子当前位置
2. 让盒子在当前位置加上1个移动距离
3. 利用定时器不动重复该操作
4. 加一个定时器结束条件
5. 注意此元素需要添加定位，才能使用element.syle.left

### 4.2动画函数简单封装

注意函数需要传递2个参数，==动画对象==和==移动到的距离==

案例：

```js
//简单动画函数封装obj是目标对象 target 目标位置
function animate(obj,target){
var timer=setInterval(function(){
if(obj.offsetLeft>=target){
clearInterval(timer);
}
obj.style.left=obj.offsetLeft+1+'px';
},30);
}
//调用函数
animate（div，300）
```



### 4.3动画函数给不同元素记录不同的定时器

如果多个元素都使用这个动画函数，每次都要var声明定时器，我们可以给不同的元素使用不同的定时器（自己专门用自己的定时器）

核心原理:利用js是一门动态语言，可以方便的给当前对象添加属性	

```js
//简单动画函数封装obj是目标对象 target 目标位置
function animate(obj,target){
obj.timer=setInterval(function(){
if(obj.offsetLeft>=target){
clearInterval(obj.timer);
}
obj.style.left=obj.offsetLeft+1+'px';
},30);
}
//调用函数
animate（div，300）
```

bug有调用的话会一直调用速度越来越快

所以需要改良一下先清除再调用改良后：

```js
//简单动画函数封装obj是目标对象 target 目标位置
function animate(obj,target){
clearInterval(obj.timer)
obj.timer=setInterval(function(){
if(obj.offsetLeft==target){
clearInterval(obj.timer);
}
obj.style.left=obj.offsetLeft+1+'px';
},30);
}
//调用函数
animate(div，300);
```

### 4.4缓动效果原理

缓动效果就是让元素运动速度有所变化，最常见的是让速度慢慢停下来

思路：

1. 让盒子每次移动的距离慢慢变小，速度就会慢慢落下来
2. 核心算法：步长公式：（目标值-现在的位置）/10做为每次移动的距离 步长
3. 停止的条件是：让当前盒子位置等于目标位置就停止定时器
4. 注意步长值取整的问题

### 4.5动画函数多个目标值之间移动

可以让动画从800回到500

当我们点击按钮调用函数时，判断步长是正值还是负值

1. 如果是正值，则步长往大了取整
2. 如果是负的则步长往小的取整

```js
//简单动画函数封装obj是目标对象 target 目标位置
function animate(obj,target){
obj.timer=setInterval(function(){
    var step=(target-obj.offseteft)/10;
    //注意步长值取整的问题
    //倒退时需要调整一下
   step>0?Math.cell (step):Math.floo r(step);
if(obj.offsetLeft>=target){
clearInterval(obj.timer);
}
obj.style.left=obj.offsetLeft+1+'px';
},30);
}
//调用函数
animate（div，300）
```

### 4.6动画函数添加回调函数

==回调函数原理:==函数可以作为一个参数将这个函数作为参数传到另一个函数里，当那个函数执行完之后，在执行传进去的这个参数，这个过程就叫做==回调==

回调函数写的位置：定时器结束的位置

### 4.7动画函数封装到单独的js文件里面

因为以后经常使用这个动画函数，可以单独封装到一个js文件里面，使用的时候直接引用这个js文件即可

## 5.常见的网页特效案例

### 5.1节流阀

防止轮播图按钮连续点击造成播放过快

节流阀目的：当前一个函数动画内容执行完毕，再去执行下一个函数动画，让事件无法连续触发

核心实现思路：利用回调函数，添加一个变量，锁住函数和解锁函数

开始设置一个变量var flag=true；

if（flag）{flag=false;do something} 关闭水龙头

利用回调函数 动画执行完毕，flag=true 打开水龙头

# 6.移动端网页特效

## 1.触屏事件

### 1.1触屏事件概述

移动端浏览器兼容性较好，我们不需要考虑以前的js兼容性问题，可以放心的使用原生js书写效果，但是移动端也有自己独特的地方，比如==触屏事件touch==，Android和IOS都有

touch对象相当于一个触摸点。触摸点可能是一根手指，也可能是一根触摸笔，触屏事件可响应用户手指（或触控笔）对屏幕或者触控板操作

常见的触屏事件：

| 触屏touch事件 | 说明                          |
| ------------- | ----------------------------- |
| touchstart    | 手指触摸到一个DOM元素时触发   |
| touchmove     | 手指在一个DOM元素上滑动时触发 |
| touchend      | 手指从一个DOM元素上移开时触发 |

## 1.2触摸事件对象（TouchEvent）

TouchEvent 是一类描述手指在莫平面(触摸屏、触莫板等)的状态变化的事件。这类事件用于描述一个或多个触点，使开发者可吸检测触点的移动，触点的增加和减少，等等

touchstart，touchmove，touchend三个事件都会有各自的事件对象

触摸事件对象重点看三个：

| 触摸列表      | 说明                                             |
| ------------- | ------------------------------------------------ |
| touches       | 正在触摸屏幕的所有手指的一个列表                 |
| targetTouches | 正在触摸当前DOM元素上的手指的一个列表            |
| changeTouches | 手指状态发生了改变的列表，从无到有，从有到无变化 |

当手指离开时没有touches和targetTouches列表返回但是有changeTouches返回

==**因为平时我们都是给元素注册触摸事件，所以重点记住targetTouches**==

## 1.3移动端拖动元素

1. touchstart、touchmove、touchend可以实现拖动元素
2. 但是拖动元素需要当前手指的坐标值我们可以使用 targetTouches[0]里面的pageX和 pageY
3. 移动端拖动的原理：手指移动中，计算出手指移动的距离，然后用盒子原来的位置+手指移动的距离
4. 手指移动的距离：手指滑动中的位置 减去 手指刚开始触摸的位置

拖动元素三步曲：

​	(1) 触摸元素touchstart:获取手指初始坐标，同时获得盒子原来的位置

​	(2) 移动手指touchmove: 计算手指的滑动距离，并且移动盒子

​	(3) 离开手指touchend:
==**注意:手指移动也会触发滚动屏幕所以这里要阻止默认的屏幕滚动 e.preventDefault（）;**==

## 2.移动端常见特效

移动端轮播图功能基本和PC端一致

1. 可以自动播放图片
2. 手指可以拖动播放轮播图

### classList属性

classList属性是HTML5新增的一个属性，返回元素的类名，但是ie10以上的版本不支持

该属性用于在元素中添加，移除及切换CSS类，有以下办法

**添加类：**

element.classList.add('类名');

```js
focus.classList.add('current');
```

**移除类:**

element.classList.remove('类名');

**切换类：**

element.classList.toggle('类名');

### 2.2click延时解决方案

移动端click事件会有300ms的延时，原因是移动端屏幕双击会缩放（doble tap to zoom）页面

解决方案：

1. 禁用缩放。浏览器禁用默认的双击缩放行为并且去掉300ms点击延迟

   ```js
   <meta name="viewport"content="user-scalable=no">
   ```

   

2. 利用touch事件自己封装这个事件解决300ms延迟

   原理就是：

   	1. 当我们手指触摸屏幕，记录当前触摸时间
   	1. 当我们手指离开屏幕，用离开的时间减去触摸的时间
   	1. 如果时间小于150ms，并且没有滑动过屏幕，那么我们就定义为点击

3. 使用插件，fastclick插件解决300ms延迟

## 3.移动端常用的开发插件

### 3.1什么是插件

移动端要求的是快速开发，所以我们经常会借助于一些插件来完成一些操作。

==js插件是js文件，==他遵循一定的规范编写，方便程序展示效果，拥有特定的功能而且方便调用如轮播图和瀑布流插件

特点：一般是为了解决某个问题而专门存在的，其功能单一并且比较小

解决延时的插件

Github地址：https://github.com/ftlabs/fastclick

### 3.2Swiper插件的使用

中文官网地址：https://www.swiper.com.cn/

1. 引入插件相关文件
2. 按照规定语法使用

### 3.3其他移动端常见插件

- superslide : http://www.superslide2.com/
- iscroll : https://github.com/cubig/iscroll

### 3.4插件的使用总结

1. 确认插件实现的功能
2. 去官网查看使用说明
3. 下载插件
4. 打开demo实例文件，查看需要引入的相关文件，并且引入
5. 复制demo实例文件中的结构html，样式css以及js代码

### 3.5练习-移动端视频插件 zy.media.js

H5给我们提供了video标签，但是浏览器的支持情况不同。

不同的视频格式文件，我们可以通过source解决。

但是外观样式，还有暂停，播放，全屏等功能我们只能自己写代码解决

这个时候我们可以使用插件方式来制作

## 4.移动端常用开发框架

### 4.1框架概述

框架，顾名思义就是一套框架，它会基于自身的特点向用户提供一套较为完整的解决方案。框架的控制控制权在框架本身，使用者要按照框架所规定的某种规范进行开发

插件一般是为了解决某个问题而专门存在的，其功能单一，并且比较小

前端常用的框架有==Bootstrap，Vue，Angular，React==等既能开发pc端也能开发移动端

前端常用的移动端插件有==swiper，superslide，iscroll==等

框架：大而全，一整套解决方案

插件：小而专一，某个功能的解决方案

# 7.本地存储

## 1.本地存储

随着互联网的快速发展，基于网页的应用越来越普遍，同时也变的越来越复杂，为了满足各种各样的需求，会经常性在本地存储大量的数据，HTML5规范提出了相关解决方案。

**本地存储特性**

1. 数据存储在用户浏览器中
2. 设置，读取方便、甚至页面都不用刷新不丢失数据
3. 容量较大，sessionStorage约5M、localStorage约20M
4. ==只能存储字符串==，可以将对象JSON.stringify()编码后存储

## 2.window.sessionStorage

1. 生命周期为关闭浏览器窗口
2. 在同一个窗口（页面）下数据可以共享
3. 以键值对的形式存储使用的

**存储数据：**

```js
sessionStorage.setltem(key,value)
```

**获取数据：**

```js
sessionStorage.gettem(key)
```

**删除数据：**

```js
sessionStorage.removeitem(key)
```

**删除所有数据：**

```js
sessionStorage.clear()
```

## 3.window.localStorage

1. 生命周期永久生效，除非手动删除否则关闭页面也会存在
2. 可以多窗口（页面）共享（同一浏览器可以共享）
3. 以键值对的形式存储使用

**存储数据：**

```js
localStorage。setltem(key,value)
```

**获取数据：**

```js
localStorage.getltem(key)
```

**删除数据：**

```js
localStorage.removeitem(key)
```

**删除所有数据：**

```js
localStorage.dear()
```

# 8.jQuery入门

## 1.jQuery概述

### 1.1JavaScript库

仓库：可以把很多东西放到这个仓库里面，找东西只需要到仓库里面找就可以了

**JavaScript库：**即library，是一个==封装==好的特定的==集合==（方法和函数），从封装一大堆函数的角度理解库，就是在这个库里，封装了很多预先定义好的函数在里面，比如动画animate，hide，show，比如获取元素等

简单理解：就是一个js文件，里面对我们原生代码进行了封装，存放在里面，这样就可以高效的使用这些封装好的功能了

比如jQuery，就是为了快速方便带的操作DOM，里面基本都是函数（方法）

**常见的JavaScript库**

- jQuery
- Prototype
- YUI
- Dojo
- Ext JS
- 移动端的zepto

这些库都是对原生的JavaScript的封装，==内部都是用JavaScript实现的==，我们主要学jQuery

### 1.2jQuery的概念

==jQuery==是一个快速的，简洁的JavaScript库，其设计的宗旨就是‘write less，Do More’即少代码做多事

j就是JavaScript;面的功能。
Query查询;意思就是查询js，把js中的DOM操作做了封装，我们可以快速的查询使用里

==jQuery封装了JavaScript常用的功能代码==，优化了DOM操作。事件处理，动画设计和Ajax交互

**优点：**

- 轻量级。核心文件才几十kb，不会影响页面加载速度
- 跨浏览器兼容。基本兼容了现在主流的浏览器
- 链式编程、隐式迭代
- 对事件、样式、动画支持，大大简化了DOM操作
- 支持插件扩展开发。有着丰富的第三方的插件，例如树形菜单、日期控件、轮播图等
- 免费、开源

## 2.jQuery的基本使用

### 2.1jQuery的下载

官网地址：https://jquery.com/

版本：

- 1x：兼容ie678等低版本浏览器，官网不在更新
- 2x：不兼容ie678等低版本服务器，官网不再更新
- 3x：不兼容ie678等低版本浏览器，是官方主要更新维护的版本

各个版本的下载：https://code.jquery.com/

### 2.2jQuery的使用步骤

1. 引入jQuery文件
2. 使用即可

### 2.3jQuery的入口函数

```js
$(function(){
...//此处是页面DOM加载完成的入口
})；
```

```js
$(document).ready(function(){
...//此处是页面DOM加载完成的入口
})
```

1. 等着DOM 结构染完毕即可执行内部代码，不必等到所有外部资源加载完成，jQuery 帮我们完成了封装
2. .相当于原生js 中的DOMContentLoaded.
3. 不同于原生js 中的load 事件是等页面文档、外部的js文件、CSS文件、图片加载完毕才执行内部代码.
4. 更推荐第一种方式

### 2.4jQuery的顶级对象$

1. $是jQuery的别称，在代码中可以使用jQuery代替$，但一般为了方便都直接使用$
2. $是jQuery的顶级对象，相当于原生JavaScript中的window，把元素利用$包装成jQuery对象，就可以调用jQuery的方法

### 2.5jQuery对象和DOM对象

1. 用原生js获取过来的对象就是DOM对象
2. 用jQuery方法获取的对象就是jQuery对象
3. jQuery对象的本质是：利用$对DOM对象包装后产生的对象（伪数组形式存储）
4. jQuery对象只能使用jQuery方法，DOM对象则使用原生的JavaScript属性和方法

DOM对象与jQuery对象之间是可以相互转换的

因为原生js比jQuery更大，原生的一些属性和方法jQuery没有给我们封装 要想使用这些属性和方法需要把jQuery对象转化为DOM对象才能使用

1. DOM对象转化为jQuery对象：==$(DOM对象)==

```js
$('div')
```

2. jQuery对象转化为DOM对象（两种方式）

```js
$('div')[index] index是索引号
```

```js
$('div').get(index) index是索引号
```

# 9.jQuery常用API

## 1.jQuery选择器

### 1.1jQuery基础选择器

原生JS 获取元素方式很多，很杂，而且兼容性情况不一致，因此Query给我们做了封装，使获取元素统一标准

```js
$("选择器")//里面选择器直接写css选择器即可，但是要加引号
```

| 名称       | 用法            | 描述                     |
| ---------- | --------------- | ------------------------ |
| ID选择器   | $("#id")        | 获取指定ID的元素         |
| 全选选择器 | $("*")          | 匹配所有元素             |
| 类选择器   | $(".class")     | 获取同一类class的元素    |
| 标签选择器 | $("div")        | 获取同一类标签的所有元素 |
| 并集选择器 | $("div,p,li")   | 选取多个元素             |
| 交集选择器 | $("li.current") | 交集元素                 |

### 1.2jQuery层级选择器

| 名称       | 用法        | 描述                                                        |
| ---------- | ----------- | ----------------------------------------------------------- |
| 子代选择器 | $("ul>li"); | 使用>号获取亲儿子层级元素；注意，并不会获取孙子的层级的元素 |
| 后代选择器 | $("ul li"); | 使用空格，代表后代选择器，获取ul下的所有元素，包括孙子等    |

### 1.3隐私迭代

遍历内部DOM元素（伪数组形式存储）的过程就叫做==隐私迭代==

简单来讲就是给匹配到的所有的元素进行循环遍历，执行相应的方法，而不用我们在进行循环，简化我们的操作，方便我们调用

### 1.4jQuery筛选选择器

| 语法          | 用法            | 描述                                                      |
| ------------- | --------------- | --------------------------------------------------------- |
| ：first       | $('li:first')   | 获取第一个元素                                            |
| ：last        | $('li:last')    | 获取最后一个li元素                                        |
| ：eq（index） | $(''li:eq(2)'') | 获取到的li元素中，选择索引号为2的元素，索引号index从0开始 |
| ：odd         | $(''li:odd'')   | 获取到的li元素中，选择索引号为奇数的元素                  |
| ：even        | $(''li:even'')  | 获取到的li元素中，选择索引号为偶数的元素                  |

### 1.5jQuery筛选方法

| 语法                   | 用法                           | 说明                                                   |
| ---------------------- | ------------------------------ | ------------------------------------------------------ |
| ==parent()==           | $("i").parent();               | 查找父级                                               |
| ==children(selector)== | $("ul").children("li")         | 相当于 $("u1>l")，最近一级 (亲儿子)                    |
| ==find(selector)==     | $("ul").find("li");            | 相当于$(ulli"),后代选择器                              |
| ==siblings(selector)== | $(".first").siblings("li");    | 查找兄弟节点，不包括自己本身                           |
| nextAll([expr])        | $(".first").nextA11()          | 查找当前元素之后所有的同辈元素                         |
| prevtAl1([expr])       | $(".last").prevAl1()           | 查找当前元素之前所有的同辈元素                         |
| hasClass(class)        | $('div').hasClass("protected") | 检查当前的元素是否含有某个特定的类，如果有，则返回true |
| ==eq(index)==          | $("li").eq(2);                 | 相当于$("li:eq(2)"),index 从0开始                      |

### 1.6jQuery里面的排他思想

想要多选一的效果，排他思想：当前元素设置样式，其余的兄弟元素清除样式

### 1.7链式编程

链式编程是为了节省代码量，看起来更优雅

```js
$(this).css('color',red).sibling().css('color','')
```

## 2.jQuery样式操作

### 2.1操作css方法

jQuery可以使用css方法来修改简单的元素样式；也可以操作类，修改多个样式

1. 参数只写了属性名，则是返回属性值

   ```js
   $(this).css("color");
   ```

2. 参数是==属性名，属性值，逗号分隔==是设置一组样式，属性必须加引号，值如果是数字尅不用跟单位和引号

   ```js
   $(this).css("color","red");
   ```

3. 参数可是对象的形式，方便设置多组样式，属性名和属性值用冒号隔开，==属性可以不加引号==

   ```js
   $(this).css({"color":"white","font-size":"20px"});
   ```

   

### 2.2设置类样式方法

作用等同于以前的classList，可以操作类样式，注意操作类里面的参数不要加点

1. 添加类

   ```js
   $("div").addClass("current")
   ```

2. 移除类

   

   ```js
   $("div").removeClass("current")
   ```

3. 切换类

   

   ```js
   $("div").toggleClass("current")
   ```

### 2.3类操作与className区别

原生js中className会覆盖元素原先里面的类名

jQuery里面的类操作只是对指定类进行操作，不影响原先的类名

## 3.jQuery效果

### 3.1显示隐藏效果

#### 1. 显示语法规范

```js
show([speed,[easing],[fn]])
```

#### 2. 显示参数

（1）参数都可以忽略，无动画直接显示

（2）speed：三种预定速度之一的字符串（"slow","normal","or","fast"）或表示动画时长的毫秒数值（如：1000）

（3）easing：（Optional）

用来切换指定效果，默认是“swing”，空参数“linear”

（4）fn：回调函数，在动画完成时执行的函数，每个元素执行一次

#### 1. 隐藏语法规范

```js
hide([speed,[easing],[fn]])
```

#### 2. 显示参数

（1）参数都可以忽略，无动画直接显示

（2）speed：三种预定速度之一的字符串（"slow","normal","or","fast"）或表示动画时长的毫秒数值（如：1000）

（3）easing：（Optional）

用来切换指定效果，默认是“swing”，空参数“linear”

（4）fn：回调函数，在动画完成时执行的函数，每个元素执行一次

### 3.2滑动效果

#### 1.下滑效果语法规范

```js
slideDown([speed,[easing],[fn]])
```

#### 2.下滑效果参数

（1）参数都可以忽略，无动画直接显示

（2）speed：三种预定速度之一的字符串（"slow","normal","or","fast"）或表示动画时长的毫秒数值（如：1000）

（3）easing：（Optional）

用来切换指定效果，默认是“swing”，空参数“linear”

（4）fn：回调函数，在动画完成时执行的函数，每个元素执行一次

### 1.滑动切换效果语法规范

```js
slideToggle([speed,[easing],[fn]])
```

#### 2.滑动切换效果参数

（1）参数都可以忽略，无动画直接显示

（2）speed：三种预定速度之一的字符串（"slow","normal","or","fast"）或表示动画时长的毫秒数值（如：1000）

（3）easing：（Optional）

用来切换指定效果，默认是“swing”，空参数“linear”

（4）fn：回调函数，在动画完成时执行的函数，每个元素执行一次

该方法对匹配元素的高度进行动画处理。这会导致页面的下半部分向上或向下滑动，似乎显示或隐藏项目。如果元素最初显示，它将被隐藏;如果隐藏，将显示它。该属性将根据需要保存和还原。如果元素的值为 ，则隐藏并显示，它将再次显示。当隐藏动画后高度达到 0 时，将 style 属性设置为 以确保元素不再影响页面的布局

### 3.3事件切换

```js
hover([over,]out)
```

​	(1) over:鼠标移到元素上要触发的函数（相当于mouseenter）

​	(2)out:鼠标移出元素要触发的函数（相当于mouseleave）

### 3.4动画队列及停止排队方法

#### 1.动画或效果队列

动画或者效果一旦触发就会执行，如果多次触发，就会造成多个动画或者效果排队执行

#### 2.停止排队

```js
stop()
```

1. stop()方法用于停止动画或者效果
2. 注意：stop（）写到动画或者效果前面，相当于停止结束上次的动画

### 3.5淡入淡出效果

**1.淡入淡出效果规范**

```js
fadeIn(speed,[easing],[fn])
```

**2.淡入效果参数**

（1）参数都可以省略

（2）speed：三种预定速度之一的字符串（"slow","normal","or","fast"）或表示动画时长的毫秒数值（如：1000）

（3）easing：（Optional）

用来切换指定效果，默认是“swing”，空参数“linear”

（4）fn：回调函数，在动画完成时执行的函数，每个元素执行一次

- 淡出fadeOut
- 切换fadeToggle

#### 渐进效果调节到指定的不透明度

```js
fadeTo([[speed],opacity,[easing],[fn]])
```

**==效果参数==**

1. opacity透明度必须写，取值在0-1之间其它参数不变
2. 熟读speed和透明度opacity这俩参数必须写不能像之前一样省略

### 3.6自定义动画animate

**1.语法**

```js
animate(params,[speed],[easing],[fn])
```

**2.参数**

（2）params：想要修改的样式属性，以对象的形式传递，必须写。属性名不用加引号，如果是复合属性则需要采取驼峰命名法，其它参数都可以省略

## 5.jQuery属性操作

### 5.1设置或获取元素固有属性值 prop（）

所谓元素固有属性就是元素本身自带的属性，比如<a>元素里面的href，比如<input>元素里面的type

**1.获取属性语法**

```js
prop("属性")
```

**2.设置属性语法**

```js
prop("属性"，属性值)
```

### 5.2设置或获取元素自定义属性值 attr( )

用户自己给元素添加的属性，我们称之为自定义属性，比如给div添加index=“1”。

**1.获取属性语法**

```js
attr("属性")// 类似原生getAttribute()
```

**2.设置属性语法**

```js
attr("属性","属性值")//类似原生setAttribute()
```

该方法也可以获取H5自定义属性

### 5.3数据缓存 date( )

date()方法可以在指定的元素上存储数据，并不会修改DOM元素结构，一旦页面刷新，之前存放的数据都将被溢出

**1.附加数据语法**

```js
data("name","value")//向被选元素附加数据
```

**2.获取数据语法**

```js
data("name")//向被选元素获取数据
```

同时，还可以读取HTML5自定义属性data-index，得到的是==数字型==

## 6.jQuery 内容文本值

主要针对元素的内容还有表单的值的操作

**1.普通元素内容html（）（相当于原生inner HTML）**

```js
html()//获取元素内容
```

```js
html("内容")//设置元素的内容
```

**2.普通元素内容text（）（相当于原生inner Text）**

方式与上面一样改为文本内容

**3.表单的值val（）（相当于原生value）**

获取设置表单值

## 6.jQuery元素操作

主要是遍历，创建，添加，删除元素操作

### 6.1遍历元素

jquery隐私迭代是对同一类元素做了相同操作，如果想要给同一类元素做不同操作，就需要用到遍历

**语法1：**

```js
$("div").each(function(index,domEle){xxx;})
```

1. each()方法遍历匹配的每一个元素。主要用DOM处理，each每一个
2. 里面的回调函数有2个参数：index是每个元素的索引号；demEle是每个DOM元素对象，不是jQuery对象
3. 所以想要使用jquery方法，需要给这个dom元素转化为jquery对象$(domEle)

**语法2**

```js
$.each(object,function(inedx,element){xxx;})
```

1. $.each()方法可用于遍历任何对象。主要用于数据处理，比如数组，对象
2. 里面的函数有2个参数：index是每个元素的索引号；element遍历内容

### 6.2创建元素

**语法：**

```js
$("<li></li>");
```

### 6.3添加元素

**1.内部添加**

```js
element.append("内容")
```

把内容放入匹配元素内部最后面，类似于appendChild。

```js
element.prepend(li);
```

把内容放入匹配元素内部最前面，

**2.外部添加**

```js
element.after（“内容”）//把内容放入目标元素后面
```

```js
element.before（“内容”）//把内容放入目标元素前面
```

**==注意==**

1. 内部元素添加，生成后他们是父子关系
2. 外部添加元素，生成之后，他们是兄弟关系

### 6.4删除元素

```js
element.remove()//删除匹配的元素(本身)
```

```js
element.empty()//删除匹配的元素集合中所有的子节点
```

```js
element.html("")//清空匹配的元素内容
```

## 7.jQuery尺寸。位置操作

### 7.1jQuery尺寸

| 语法                                   | 用法                                              |
| -------------------------------------- | ------------------------------------------------- |
| width（）/height（）                   | 取得匹配元素的宽度和高度值，只算width/height      |
| innerWidth（）/innerHeight（）         | 取得匹配元素宽度和高度值包括padding               |
| outerWidth（）/outerHeight（）         | 取得匹配元素宽度和高度值包括padding,border        |
| outerWidth（true）/outerHeight（true） | 取得匹配元素宽度和高度值包括padding,border.margin |

- 以上参数为空，则是获取相应值，返回数字型
- 如果参数为数字，则是修改相应值
- 参数可以不写单位

### 7.2jQuery位置

位置主要有三个：offset（），position（），scrollTop（）/scrollLeft（）

#### 1. offset()方法设置或返回被选元素相对于==文档==的偏移坐标

- offset（）方法设置或返回被选元素相对于文档的偏移坐标跟父级没关系

#### 2.position（）获取元素偏移

- position（）方法用于返回被选元素相对于==带有定位的父级==偏移坐标，如果父级都没有定位，则以文档为准
- 这个方法只能获取不能设置偏移

#### 3.scrollTop（）/scrollLeft（）设置或获取元素被卷去的头部和左侧

- scrollTop（）方法设置或返回被选元素被卷去的头部                            

# 10.jQuery事件

## 1.jQuery事件注册

**单个事件注册**                                                        

语法：

```js
element.事件(function(){})
```

```js
$("div").click(function(){})(事件处理程序)
```

其他事件和原生基本一致

比如mouseover，mouseout，blur，focus，change，keydown，keyup，resize，scroll等

## 2.jQuery事件处理

### 2.1事件处理on（）绑定事件

on（）方法在匹配元素上绑定一个或多个事件的事件处理函数

**语法：**

```js
element.on(events,[selector],fn)
```

1. events:一个或多个用空格分隔的事件类型，如"click"或"keydown"
2. selector:元素的子元素选择器
3. fn：回调函数即绑定在元素身上的侦听函数

**on（）方法的优势1：**

可以绑定多个事件，多个处理事件处理程序。

```js
$("div").on({
mouseover:function(){},
mouseout:function(){},
click:function(){}
});
```



**on()方法优势2：**

可以事件委派操作，事件委派的定义就是，把原来加给子元素身上的事件绑在父元素上，就是把事件委派给父元素

```js
$('div').on('click','li',function(){
xxx;
})
```

   在此之前有bind（），live（）delegate（）等方法来处理事件绑定程序或者事件委托，最新版本的请用==on==替代他们

**on（）方法优势3：**

动态创建的元素。click（）没有办法绑定事件。on（）可以给动态生成的元素绑定事件

### 2.2事件处理off（）解绑事件

off（）方法可以移除on（）方法添加的事件处理程序。

```js
$("p").off()//解绑p元素所有事件处理程序
$("p").off("click")//解绑p元素上面的点击事件 后面是foo是侦听函数名
$("ul").off("click","li");//解绑事件委托
```

如果有的事件只想触发一次，可以用one（）来绑定事件

### 2.3自动触发事件trigger（）

有些事件希望自动触发，比如轮播图自动播方功能跟点击右侧按钮一致，可以利用定时器自动触发右侧按钮点击事件，不必鼠标点击触发

```js
element.click()//第一种简写形式
```

```js
element.trigger("type")//第二种自动触发方式
```

```js
element.triggerHandler(type)//第三种自动触发方式
```

第三种不会触发元素的默认行为

## 3.jQuery事件对象

事件被触发，就会有事件对象的产生

```js
element.on(events,[selector],function(event){})
```

阻止默认行为：event.preventDefault（）或者return false

阻止冒泡：event。stopPropagation（）

# 11.jQuery其他方法

## 1.jQuery拷贝对象

如果想要把某个对象拷贝（合并）给另外一个对象使用，此时可以使用$.extend方法

**语法：**

```js
$.extend([deep],target,object1,[objectN])
```

1. deep:如果设为true为深拷贝，默认为false浅拷贝
2. target：要拷贝的目标对象
3. object1：待拷贝到第一个对象的对象
4. 如果有相同数据，会直接覆盖
5. 浅拷贝是把被拷贝的对象==复杂数据类型中的地址==拷贝对象，修改目标对象==会影响==被拷贝对象
6. 深拷贝，前面加true，完全克隆（拷贝的对象而不是地址），修改目标对象==不会影响到==被拷贝对象，如果有不冲突的属性会合并在一起，冲突的还是会覆盖

## 2.jQuery多库共存

问题概述：

jQuery使用$做为标识符，随着jQuery的流行其他js库也会用他来当标识符，一起使用会引起冲突

客观需求：

需要一个解决方案，让jQuery和其他的js库不存在冲突，可以同时存在，这就叫多库共存

jQuery解决方案：

1. 把$统一改成jQuery。比如jquery（"div"）
2. jquery变量规定新的名称：$.noConflict() var xx=$.noConflict();

## 3.jQuery插件

jquery功能有限想要复杂的特效效果，可以借助jquery插件完成

注意：这些插件也是依赖于jQuery来完成的，所以必须先引进jQuery文件，因此也称为jQuery插件

jQuery插件常用网站

1. jQuery插件库 http://www.jq22.com/
2. jQuery之家 http://www.htmleaf.com/（更推荐）

jQuery插件使用步骤：

1. 引入相关文件（jQuery文件和插件文件）
2. 复制相关html、css、js（调用插件）

**jQuery插件演示：**

1. 瀑布流

2. 图片懒加载（图片使用延迟加载在可提升网页下载速度，他也能减轻服务器负载）

   当我们页面滑动到可视区域，再显示图片

   我们使用jQuery插件库EasyLazyload。注意，此时的js引入文件和js调用必须写到DOM元素（图片）最后面

3. 全屏滚动（fullpage.js）

   gitHub：http://github.com/alvarotrigo/fullPage.js

   中文翻译网站：http://www.dowebok.com/demo/2014/77/

**bootstrap JS插件：**

bootstrap框架也是依赖于jQuery开发的，因此里面的js插件使用也必须引入jQuery文件

# 12.数据可视化

## 1.什么是数据可视化

### 1.1数据可视化

- 数据可视化主要目的：借助图形化手段，清晰有效地传达与沟通信息
- 数据可视化可以把数据从冰冷的数字转化为图形，揭示蕴含在数据中的规律和道理

### 1.2数据可视化的场景

目前数据可视化通常有这么几大类可视化需求：

1. 通用报表
2. 移动端图表
3. 大屏可视化
4. 图编辑图分析
5. 地理可视化

### 1.3常见的数据可视化库

- D3.js 目前Web端评价最高的JavaScript可视化工具库（入手难）
- ==EChart.js 百度出品的一个开源JavaScript数据可视化库==
- ==Highchart.js 国外的前端数据可视化库，非商用免费，被许多国外大公司所使用==
- AntV蚂蚁金服全新一代数据可视化解决方案
- 等等

## 2.数据可视化项目概述

### 项目目的

市场需求：

应对现在数据可视化趋势，越来越多企业需要在很多场景下（营销数据、生产数据，用户数据）下使用，**可视化图表**来展示体现数据，让数据更加直观，数据特点更加突出

学习阶段需求：

项目对我们来说起到承上启下作用

乘上：

- 复习以前学习的内容
- H5C3布局相关技术
- JavaScript/jQuery相关技术

启下：

- 为学习服务器编程做铺垫
- 如何把服务器里面的数据渲染到页面中

## 项目技术

- H5C3布局
- CSS3动画+渐变
- jQuery库+原生JavaScript
- flex布局和rem适配方案
- ==图片边框 boder-image==
- ==ES6模版字符==
- ==EChart可视化库等等==

## 3.ECharts简介

ECharts是一个使用 JavaScript 实现的开源可视化库，可以流畅的运行在 P和移动设备上，兼容当前绝大部分浏览器 (IE8/9/10/11，Chrome，Firefox，Safari等)，底层依赖矢量图形库ZRender，提供直观，交互丰富，可高度个性化定制的数据可视化图表

官网地址: (https://echarts.apache.org/zh/download.html)

- 丰富的可视化类型
- 多种数据格式支持
- 流数据的支持
- 移动端优化
- 跨平台使用
- 绚丽的特效
- 详细的文档说明

**EChart能满足绝大多数可视化图表实现，使用方便，功能强大，是实现数据可视化的最优选择之一**

## 4.EChart的基本使用

### 4.1EChart使用五步曲

步骤1：下载并引入echarts,js文件-------->图表依赖于这个==js库==

步骤2：准备一个具备大小的DOM容器------>生成的图表会放入这个==容器==

步骤3：初始化echarts实例对象------>==实例化==echarts对象

步骤4：指定配置项和数据（option）------->根据具体要求修改==配置==选项

步骤5：将配置项设置给echarts实例对象------>让echarts对象根据修好的配置==生效==

### 4.2相关配置讲解

- title:标题组件
- tooltip: 提示框组件
- legend:图例组件
- toolbox:工具栏
- grid:直角坐标系内绘图网格
- xAxis:直角坐标系 grid 中的x轴
- yAxis:直角坐标系grid 中的y轴
- series: 系列列表。每个系列通过 type 决定自己的图表类型(什么类型的图标
- color:调色盘颜色列表

==先了解以上9个配置的作用，其余配置有具体细节我们查阅文档: 文档菜单一配置项手册学echarts关键在于学会查阅文档，根据需求修改配置==
srries：系列列表

- type:类型(什么类型的图表) 比如 line 是折线 bar 柱形等

- name: 系列名称，用于tooltip的显示，legend 的图例筛选 变化

- stack: 数据堆叠。如果设置相同值，则会数据堆叠

  数据堆叠：

  第二个数据值=第一个数据值+ 第二个数据值数据堆叠:
  第三个数据值 =第二个数据值 + 第三个数据值....依次叠加如果给stack 指定不同值或者去掉这个属性则不会发生数据堆叠

# 13.数据可视化项目

## 1.数据可视化项目适配方案

### 1.1项目需求

- 设计稿是1920px
- pc端适配：宽度在1024~1920之间页面元素宽高自适应

### 1.2适配方案

flexible.js检测浏览器宽度修改html文字大小

rem单位页面元素根据rem适配大小配合cssrem插件

flex布局页面快速布局

## 2.数据可视化项目开发

### 2.2边框图片

1. 边框图片使用场景

   为了实现丰富多彩的边框效果，在CSS3中，新增了border-image属性，这个新属性允许指定一幅图像作为边框的元素

2. 边框图片切图原理（重要）

   把四个角切出去（九宫格的由来），中间部分可以铺排、拉伸或者环绕

3. 边框图片语法规范（重要）

   | 属性                | 描述                                                         |
   | ------------------- | ------------------------------------------------------------ |
   | border-image-source | 用在边框的图片路径（那个图片？）                             |
   | border-image-slice  | 图片边框向内偏移（裁剪的尺寸，一定不加单位，上右下左顺序）   |
   | borde-image-slice   | 图片边框的宽度（需要加单位）（不是边框的宽度是边框图片的宽度） |
   | border-image-width  | 图像边框是否应平铺（repeat），铺满（round）或==拉伸（stretch）默认拉伸== |

   

### 2.3公共面板开发

面板类：.panel

### 2.4通过类命来调用字体图标

1. HTML页面中引入字体图标中css文件
2. 标签直接调用图标对应的类名即可（类名在css文件中标注）

### 2.5立即执行函数用法

js文件中，会有大量的变量命名，特别是Echarts使用中，需要大量初始化Echarts对象？

为了防止我们的变量名冲突（变量污染）我们采用立即执行函数策略：

```js
(function(){})();
```

```js
(function(){
var num=10;
})();
(function(){
var num=10;
})();
```

**==注意：多个立即执行函数中间必须加分号隔开== **

### 2.6无缝滚动原理

1. 先克隆marquee里面所有的行 (row)
2. 通过CSS3动画滚动marquee
3. 鼠标经过marquee 就停止动画:
   animation-play-state: paused;
